/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7c66d734-bbe3-4d2f-9279-2d3ede8b52fa
-/

/-
Formalization of the "Almost Impossible Puzzle" solution.
We define `HasStrategy` to represent the existence of a winning strategy.
We prove `strategy_iff_power_of_two`, which states that a strategy exists if and only if $n$ is a power of 2.
The proof involves:
1. `strategy_implies_dvd`: If a strategy exists, then $n$ divides $2^n$.
2. `dvd_two_pow_implies_power_of_two`: If $n$ divides $2^n$, then $n$ is a power of 2.
3. `power_of_two_implies_strategy`: If $n$ is a power of 2, we construct a strategy using the vector space structure of $\mathbb{Z}_2^m$.
-/

/-
Let $I=\{1,\ldots,n\}$, where $n\ge1$. In the following, we consider $\mathbb{Z}_2^m=\mathbb{Z}_2\times...\times\mathbb{Z}_2$ as a vector space over $\mathbb{Z}_2$, where $m\in\mathbb{N}^*$. For $i\in I$, let $e_i\in\mathbb{Z}_2^n$ be the canonical vector with $1$ on the $i$-th position and zeros elsewhere. Note that $z+e_i$ is the code $z$ with the $i$-th bit flipped, for every $z\in\mathbb{Z}_2^n$ and $i\in I$.

Prove that:

[there exists $f:\mathbb{Z}_2^n\to I$ such that for every $z\in\Zz^n$ and every $k\in I$ there exists $i\in I$ such that $f(z+e_i)=k$]
iff
[there exists $m∈\mathbb{N}^*$ such that $n\le 2^m$].
-/


/-
Definition of the existence of a strategy for the puzzle. A strategy exists if there is a function f such that for any code z and any target k, there is a bit i such that flipping the i-th bit of z results in a code that f maps to k.
-/
import Mathlib.Data.Nat.Basic
import Mathlib.Data.ZMod.Basic
import Mathlib.Algebra.Module.Pi
import Mathlib.LinearAlgebra.StdBasis
import Init.Data.Fin.Basic
import Mathlib.Algebra.Group.Action.Pointwise.Finset

set_option linter.style.longLine false
set_option linter.style.refine false

def HasStrategy (n : ℕ) : Prop :=
  ∃ f : (Fin n → ZMod 2) → Fin n,
    ∀ (z : Fin n → ZMod 2) (k : Fin n), ∃ i : Fin n, f (z + Pi.single i 1) = k

/-
The Hamming sphere of radius 1 around z has size n.
-/
def HammingSphere {n : ℕ} (z : Fin n → ZMod 2) : Finset (Fin n → ZMod 2) :=
  Finset.image (fun i => z + Pi.single i 1) Finset.univ

lemma card_hamming_sphere {n : ℕ} (z : Fin n → ZMod 2) : (HammingSphere z).card = n := by
  unfold HammingSphere;
  rw [ Finset.card_image_of_injective _ fun i j hij => ?_, Finset.card_fin ];
  rw [ funext_iff ] at hij;
  by_cases hi : i = j <;> specialize hij i <;> aesop;

/-
If a strategy exists, then for any code z, the function f maps the Hamming sphere around z bijectively onto the set of possible secret numbers.
-/
lemma strategy_bij_on_sphere {n : ℕ} (h : HasStrategy n) (f : (Fin n → ZMod 2) → Fin n)
    (hf : ∀ (z : Fin n → ZMod 2) (k : Fin n), ∃ i : Fin n, f (z + Pi.single i 1) = k)
    (z : Fin n → ZMod 2) :
    (HammingSphere z).image f = Finset.univ ∧ ∀ k, ∃! i, f (z + Pi.single i 1) = k := by
  -- Since $f$ maps the Hamming sphere around $z$ bijectively onto $Fin n$, $f$ must be a bijection from the Hamming sphere to $Fin n$.
  have bijection_hamming_sphere : Function.Bijective (fun x : Fin n => f (z + Pi.single x 1)) := by
    exact Function.Surjective.bijective_of_finite (hf z);
  refine' ⟨ _, _ ⟩;
  · simp_all +decide [ Finset.ext_iff, Function.Bijective ];
    exact fun a => by obtain ⟨ i, hi ⟩ := bijection_hamming_sphere.2 a; exact ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_univ i ), hi ⟩ ;
  · exact fun k => bijection_hamming_sphere.existsUnique k

/-
If a strategy exists, then n divides 2^n.
-/
lemma strategy_implies_dvd (n : ℕ) (h : HasStrategy n) : n ∣ 2 ^ n := by
  obtain ⟨ f, hf ⟩ := h;
  -- Let $S = \{x \in \text{Fin } n \to \mathbb{Z}_2 \mid f(x) = k\}$ for some fixed $k$.
  let k := f 0
  have h_partition : ∀ x : Fin n → ZMod 2, ∃ x' ∈ {x : Fin n → ZMod 2 | f x = k}, x ∈ HammingSphere x' := by
    intro x
    obtain ⟨i, hi⟩ := hf x k;
    use x + Pi.single i 1;
    simp_all +decide [ HammingSphere ];
    exact ⟨ i, by ext j; by_cases h : j = i <;> simp_all +decide [ add_assoc ] ⟩;
  -- Since the Hamming spheres are disjoint and cover the entire space, we have $|\text{Fin } n \to \mathbb{Z}_2| = \sum_{x \in S} |\text{HammingSphere } x|$.
  have h_card_partition : Finset.card (Finset.univ : Finset (Fin n → ZMod 2)) = Finset.sum (Finset.filter (fun x => f x = k) (Finset.univ : Finset (Fin n → ZMod 2))) (fun x => Finset.card (HammingSphere x)) := by
    rw [ ← Finset.card_biUnion ];
    · congr with x ; aesop;
    · intros x hx y hy hxy; simp_all +decide [ Finset.disjoint_left, HammingSphere ] ;
      intro a b H; have := hf x k; have := hf y k; simp_all +decide [ ← eq_sub_iff_add_eq ] ;
      have := strategy_bij_on_sphere ⟨ f, hf ⟩ f hf ( x - Pi.single b 1 ) ; simp_all +decide [ sub_eq_add_neg, add_assoc ] ;
      obtain ⟨ i, hi, hiu ⟩ := this.2 k;
      have := hiu a ( by simpa [ add_comm, add_left_comm, add_assoc ] using hy ) ; have := hiu b ( by simpa [ add_comm, add_left_comm, add_assoc ] using hx ) ; simp_all +decide ;
  -- Since each Hamming sphere has size $n$, we have $|\text{HammingSphere } x| = n$ for all $x \in S$.
  have h_card_hamming_sphere : ∀ x ∈ Finset.filter (fun x => f x = k) (Finset.univ : Finset (Fin n → ZMod 2)), Finset.card (HammingSphere x) = n := by
    exact?;
  simp_all

/-
Checking availability of basic Nat definitions and induction principles.
-/
#check Nat.succ
#check Nat.gcd
#check Nat.Coprime
#check Odd
#check Even
#check Nat.strong_induction_on

/-
If an odd number divides a power of 2, it must be 1.
-/
lemma odd_dvd_two_pow (m n : ℕ) (h_odd : Odd m) (h_dvd : m ∣ 2 ^ n) : m = 1 := by
  -- Since $m$ is odd, we can write $m = 2k + 1$ for some integer $k$.
  obtain ⟨k, rfl⟩ : ∃ k, m = 2 * k + 1 := h_odd;
  have := Nat.dvd_gcd ( dvd_refl ( 2 * k + 1 ) ) h_dvd; simp_all +decide [ Nat.Coprime, Nat.Coprime.pow_right ] ;

/-
If n divides 2^n, then n is a power of 2.
-/
lemma dvd_two_pow_implies_power_of_two (n : ℕ) (h : n ∣ 2 ^ n) : ∃ m, n = 2 ^ m := by
    rw [Nat.dvd_prime_pow Nat.prime_two]  at h
    rcases h with ⟨m, hm⟩
    use m
    exact hm.2

/-
If n is a power of 2, then a strategy exists.
-/
lemma power_of_two_implies_strategy (n m : ℕ) (h : n = 2 ^ m) : HasStrategy n := by
  subst h;
  -- Define the bijection $\phi$ between the set $\{0, 1, ..., 2^m - 1\}$ and the vector space $(Fin m -> ZMod 2)$.
  obtain ⟨phi, hphi⟩ : ∃ phi : Fin (2 ^ m) ≃ (Fin m → ZMod 2), True := by
    exact ⟨ Fintype.equivOfCardEq <| by simp +decide [ Fintype.card_fin ], trivial ⟩;
  -- Define the function $g$ as the linear map that sends the $i$-th basis vector to $\phi(i)$.
  obtain ⟨g, hg⟩ : ∃ g : (Fin (2 ^ m) → ZMod 2) → (Fin m → ZMod 2), (∀ z : Fin (2 ^ m) → ZMod 2, ∀ k : Fin m → ZMod 2, ∃ i : Fin (2 ^ m), g (z + Pi.single i 1) = k) := by
    use fun z => ∑ i, z i • phi i;
    intro z k; use phi.symm ( k - ∑ i, z i • phi i ) ; simp +decide [ Finset.sum_add_distrib, add_smul ] ;
  use fun z => phi.symm ( g z );
  exact fun z k => by obtain ⟨ i, hi ⟩ := hg z ( phi k ) ; exact ⟨ i, by simp +decide [ hi ] ⟩ ;

/-
A strategy exists if and only if n is a power of 2.
-/
theorem strategy_iff_power_of_two (n : ℕ) : HasStrategy n ↔ ∃ m, n = 2 ^ m := by
  constructor
  · intro h
    have h_dvd := strategy_implies_dvd n h
    exact dvd_two_pow_implies_power_of_two n h_dvd
  · rintro ⟨m, rfl⟩
    exact power_of_two_implies_strategy (2 ^ m) m rfl
